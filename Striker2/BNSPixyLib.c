//#pragma config(UART_Usage, UART1, uartUserControl, baudRate38400, IOPins, None, None)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

typedef struct
{
  int sig;
  int x;
  int y;
  int width;
  int height;
} PixyBlock;

PixyBlock pixyBlocks[10];
int pixyBlockNum;
bool pixyBlockHasUpdated;

char getNextChar()
{
  while (1)
  {
    short c = getChar(UART1);

    if (c != -1)
      return (char)c;
  }
}

int getNextInt()
{
  char n1 = getNextChar();
  char n2 = getNextChar();
  return n1 | (n2 << 8);
}

task pixyUpdate()
{
  int skip = false;
  int count = 0;
  int zeroCount = 0;
  while (1)
  {
    pixyBlockNum = count;
    pixyBlockHasUpdated = true;
    count = 0;
    char c = 0xFF;

    while(skip == false)
    {
      if (c == 0) zeroCount++;

      if (zeroCount > 10)
      {
        zeroCount = 0;
        pixyBlockNum = 0;
        pixyBlockHasUpdated = true;
      }
      // Look for 0xAA55 tag
      c = getNextChar();
      if (c != 0x55) continue;

      c = getNextChar();
      if (c != 0xaa) continue;

      c = getNextChar();
      if (c != 0x55) continue;

      c = getNextChar();
      if (c != 0xaa) continue;

      break;
    }

    skip = false;

    while(1)
    {
      // We don't care about checksum for now
      char cs1 = getNextChar();
      char cs2 = getNextChar();

      if (cs1 == 85 && cs2 == 170)
      {
        skip = true;
        break;
      }

      // Data
      int sig = getNextInt();
      int x = getNextInt();
      int y = getNextInt();
      int width = getNextInt();
      int height = getNextInt();

      if (count >= 10) break;

      pixyBlocks[count].sig = sig;
      pixyBlocks[count].x = x;
      pixyBlocks[count].y = y;
      pixyBlocks[count].width = width;
      pixyBlocks[count].height = height;

      count++;

      int c1 = getNextChar();
      int c2 = getNextChar();
      if (c1 != 0x55 || c2 != 0xAA) break;
    }
  }
}
