#pragma config(UART_Usage, UART1, uartUserControl, baudRate38400, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartUserControl, baudRate38400, IOPins, None, None)
#pragma config(Sensor, in1,    rLine,          sensorLineFollower)
#pragma config(Sensor, in2,    selector1,      sensorAnalog)
#pragma config(Sensor, in3,    selector2,      sensorAnalog)
#pragma config(Sensor, in4,    pot,            sensorAnalog)
#pragma config(Sensor, in5,    lLine,          sensorLineFollower)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  hangingLock,    sensorDigitalOut)
#pragma config(Sensor, dgtl4,  intake,         sensorDigitalOut)
#pragma config(Sensor, dgtl5,  pusher,         sensorDigitalOut)
#pragma config(Sensor, dgtl6,  frontSonar,     sensorSONAR_raw)
#pragma config(Sensor, dgtl8,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl10, backSonar,      sensorSONAR_raw)
#pragma config(Motor,  port2,           driveR2,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           driveR1,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           driveR3,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           liftR1,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           liftL1,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           driveL3,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           driveL1,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           driveL2,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "LCD_Vex_Competition_Includes.c"
#include "xsens.c"
#include "Robot.c"
#include "Auton.c"
#include "pixy.c"
#include "pixyAuto.c"

task gyroCalib()
{

}

void pre_auton()
{
  startTask(xsens);
  //startTask(gyroCalib);
  GyroCalibration();
  //writeDebugStreamLine("Gyro calib done");


}

void AutonCubeFar()
{
  startTask(liftHeight);
  float currentHeading = 0;

  // Turn a little and pick up cube
  currentHeading += ROTATE_RIGHT * 0.15;
  setClaw(0);
  driveHoldHeading(600, 100, currentHeading, DRIVE_ENCODERS);

  currentHeading += ROTATE_RIGHT * 0.35;

  setClaw(1);
  SetLiftHeight(LIFT_LITTLE_BIT_HEIGHT);
  driveTurnInPlace(currentHeading, PID_INPLACE_TURN_NORMAL, 20);
  driveHoldHeading(500, 100, currentHeading);
  currentHeading += ROTATE_LEFT;

  SetLiftHeight(LIFT_HIGH_HEIGHT);
  driveTurnInPlace(currentHeading);
  waitForLiftUp(LIFT_MID_CUBE_HEIGHT);

  // Score #1
  driveHoldHeading(200, 80, currentHeading);
  driveHoldHeading(550, 127, currentHeading, DRIVE_LINES, ACCEL_FAST, 80);
  setClaw(0);
  drivePower(127);
  wait1Msec(100);
  drivePower(50);
  wait1Msec(250);
	drivePower(0);


  drivePower(0);
}

float AutonCubeMid()
{
  startTask(liftHeight);
  float currentHeading = 0;

  // Turn a little and pick up cube
  currentHeading += ROTATE_RIGHT * 0.15;
  setClaw(0);
  driveHoldHeading(600, 100, currentHeading, DRIVE_ENCODERS);
  setClaw(1);
  SetLiftHeight(LIFT_HIGH_HEIGHT);

  // Turn towards fence
  currentHeading += ROTATE_LEFT / 2 + ROTATE_LEFT * 0.15;
  driveTurnInPlace(currentHeading);
  drivePower(0);
  waitForLiftUp(LIFT_LITTLE_BIT_HEIGHT);

  // Score #1
  driveHoldHeading(100, 80, currentHeading);
  driveHoldHeading(550, 127, currentHeading, DRIVE_LINES, ACCEL_FAST, 80);
  setClaw(0);
  drivePower(127);
  wait1Msec(100);
  drivePower(50);
  wait1Msec(250);
	drivePower(0);

	currentHeading += ROTATE_RIGHT / 1.9;
	driveHoldHeading(-300, -65, currentHeading);
	SetLiftHeight(LIFT_LOW_HEIGHT);
	driveHoldHeading(-750, -100, currentHeading, DRIVE_ENCODERS, ACCEL_FAST, -60);

	currentHeading += ROTATE_RIGHT * (0.9/1.9);
	driveTurnInPlace(currentHeading);
  driveHoldHeading(1650, 110, currentHeading, DRIVE_ENCODERS, ACCEL_FAST, 60);
  setClaw(1);
  drivePower(0);
  wait1Msec(300);
  SetLiftHeight(LIFT_HIGH_HEIGHT);

  currentHeading += ROTATE_LEFT;
  driveTurnInPlace(currentHeading);

  driveHoldHeading(400, 80, currentHeading);
  driveHoldHeading(550, 127, currentHeading, DRIVE_LINES, ACCEL_FAST, 80);
  setClaw(0);
  drivePower(127);
  wait1Msec(100);
  drivePower(50);
  wait1Msec(250);
	drivePower(0);

	return currentHeading;
}

void PSC()
{
    startTask(liftHeight);
    int turnAngVel = 120;
	  int turnStartSpeed = 80;
	  int currentHeading = 0;
	  int overshootConstant = 30;
    setPusher(0);
    setHangingLock(0);
    toggleSonar(BACK_ON);

	  SetLiftHeight(LIFT_LOW_HEIGHT);
	  setClaw(0);

	  driveHoldHeading(100, 60, currentHeading);
	  setClaw(1);

	  // Turn towards corner star #2 near fence
	  currentHeading += ROTATE_RIGHT;
	  turnRight(turnStartSpeed, turnAngVel, currentHeading + 10);
	  setClaw(0);
	  driveHoldHeading(500, 110, currentHeading, DRIVE_ENCODERS, ACCEL_FAST, 70);
	  setClaw(1);

	  currentHeading += ROTATE_LEFT * 2.0/13.0;
	  //turnLeft(turnStartSpeed, turnAngVel, currentHeading - overshootConstant/7, TYPE_BACKWARD);

	  // Go back to tile to get matchloads
	  driveHoldHeading(-50, -110, currentHeading, DRIVE_ENCODERS, ACCEL_FAST, -70);
	  SetLiftHeight(LIFT_HIGH_HEIGHT);
	  driveHoldHeading(-550, -110, currentHeading, DRIVE_LINES);
	  driveHoldHeading(-350, -40, currentHeading);

	  // LOADING #1
	  brake(-1);
	  //currentHeading += ROTATE_RIGHT / 7;
	  //turnRight(turnStartSpeed, turnAngVel, currentHeading + overshootConstant/7);
	  //drivePower(0);

	  // Score #1
	  currentHeading += ROTATE_RIGHT * 2.0/13.0;
	  driveHoldHeading(750, 127, currentHeading, DRIVE_ENCODERS, ACCEL_FAST, 40, 4);
	  driveHoldHeading(550, 127, currentHeading, DRIVE_LINES);
	  setClaw(0);
	  drivePower(127);
	  wait1Msec(100);
	  drivePower(50);
	  wait1Msec(250);

	  //currentHeading += ROTATE_RIGHT / 14;

	  // Backup from fence
	  // NOTE: We can cut out ~500ms here if we make it -90 instead of -70.
	  //       However, this will make the robot tip backwards as of 3/18/17
	  driveHoldHeading(-300, -70, currentHeading);
	  SetLiftHeight(LIFT_LOW_HEIGHT);
	  driveHoldHeading(5500, -70, currentHeading, DRIVE_BACK_SONAR);
	  brake(-1);

	  // Turn towards cube
	  currentHeading += ROTATE_RIGHT;
	  driveTurnInPlace(currentHeading, PID_INPLACE_TURN_NORMAL, 20);
	  driveHoldHeading(8500, 110, currentHeading, DRIVE_BACK_SONAR_FORWARD, ACCEL_FAST, 70);

	  // Grab Cube
	  setClaw(1);
	  SetLiftHeight(LIFT_MID_HEIGHT);
	  currentHeading += ROTATE_LEFT / 3.5;
	  driveHoldHeading(-480, -110, currentHeading, DRIVE_ENCODERS, ACCEL_FAST, -70);
    brake(-0.5);
    currentHeading += ROTATE_LEFT * 2.5/3.5;
	  driveTurnInPlace(currentHeading, PID_INPLACE_TURN_WITH_CUBE);

	  // LOADING #2
	  //wait1Msec(250);

	  // Score #2 cubes.
	  SetLiftHeight(LIFT_HIGH_HEIGHT);
	  driveHoldHeading(550, 80, currentHeading, DRIVE_ENCODERS, ACCEL_FAST, 50);
	  driveHoldHeading(550, 127, currentHeading, DRIVE_LINES, ACCEL_FAST, 80);
	  setClaw(0);
	  drivePower(127);
	  wait1Msec(100);
	  drivePower(50);
	  wait1Msec(250);

	  // Backup from fence
	  driveHoldHeading(-400, -70, currentHeading);
	  SetLiftHeight(LIFT_LOW_HEIGHT);
	  driveHoldHeading(4200, -70, currentHeading, DRIVE_BACK_SONAR);

	  // Turn to get "3+1" stars in the front row.
	  currentHeading += ROTATE_RIGHT * 3.0 / 6.0;
	  turnRight(turnStartSpeed, turnAngVel, currentHeading + overshootConstant);
	  driveHoldHeading(500, 70, currentHeading);
	  currentHeading += ROTATE_RIGHT * 3.0 / 6.0;
	  turnRight(turnStartSpeed, turnAngVel, currentHeading + overshootConstant/2);

	  // Get the 4 stars
	  driveHoldHeading(8500, 127, currentHeading, DRIVE_BACK_SONAR_FORWARD, ACCEL_FAST, 70, 5, -10);
	  driveHoldHeading(900, 127, currentHeading, DRIVE_ENCODERS, ACCEL_NONE, 127, 5, -10);
    setClaw(1);

    currentHeading += ROTATE_LEFT;
    turnLeft(turnStartSpeed, turnAngVel, currentHeading, TYPE_BACKWARD);

	  // Backup and raise lift
    SetLiftHeight(LIFT_HIGH_HEIGHT);
    driveHoldHeading(-300, -60, currentHeading);
    drivePower(0);
    wait1Msec(500);

    // Score #3
    driveHoldHeading(375, 127, currentHeading, DRIVE_ENCODERS, ACCEL_FAST, 70);
	  driveHoldHeading(550, 127, currentHeading, DRIVE_LINES);
	  setClaw(0);
	  drivePower(127);
	  wait1Msec(100);
	  drivePower(50);
	  wait1Msec(250);

	  // --- Delete Later
	  //SetLiftHeight(LIFT_HIGH_HEIGHT);
	  //setClaw(0);
	  //setHangingLock(0);
	  // ---

	  driveHoldHeading(-400, -70, currentHeading);
    brake(-1);

	  // Correct on wall
	  currentHeading += ROTATE_LEFT;
	  driveTurnInPlace(currentHeading, PID_INPLACE_TURN_NORMAL, 20);
	  SetLiftHeight(LIFT_LOW_HEIGHT);
	  driveHoldHeading(2000, -65, currentHeading, DRIVE_BACK_SONAR);

	  // Turn towards star in corner
	  currentHeading += ROTATE_LEFT;
	  driveTurnInPlace(currentHeading, PID_INPLACE_TURN_NORMAL, 20);

	  driveHoldHeading(300, 100, currentHeading, DRIVE_ENCODERS, ACCEL_FAST, 70);
	  setClaw(1);
	  driveHoldHeading(-150, -100, currentHeading, DRIVE_ENCODERS, ACCEL_FAST, -70);

	  currentHeading += ROTATE_RIGHT * 0.4 ;
    driveTurnInPlace(currentHeading, PID_INPLACE_TURN_NORMAL, 20);

	  // Pick up cube on red tile
	  setClaw(0);
	  driveHoldHeading(500, 100, currentHeading, DRIVE_ENCODERS, ACCEL_FAST, 70);
    setClaw(1);
    SetLiftHeight(LIFT_HIGH_HEIGHT);
  	driveHoldHeading(-300, -100, currentHeading, DRIVE_ENCODERS, ACCEL_FAST, -70);

	  // Turn towards fence and raise lift
	  currentHeading += ROTATE_RIGHT*2 + ROTATE_LEFT * 0.4;
	  driveTurnInPlace(currentHeading, PID_INPLACE_TURN_PUSHER, 10); // Pusher = star + cube? lol

	  // Score #4
	  //driveHoldHeading(100, 100, currentHeading, DRIVE_ENCODERS, ACCEL_FAST, 70);
	  driveHoldHeading(550, 127, currentHeading, DRIVE_LINES, ACCEL_FAST, 70);
	  setClaw(0);
	  drivePower(127);
	  wait1Msec(100);
	  drivePower(50);
	  wait1Msec(250);


	  driveHoldHeading(-300, -70, currentHeading);
	  SetLiftHeight(LIFT_LOW_HEIGHT);
	  driveHoldHeading(4500, -70, currentHeading, DRIVE_BACK_SONAR);
	  //driveHoldHeading(-400, -70, currentHeading);
	  brake(-1);

	  // Correct on wall
	  currentHeading += ROTATE_LEFT;
	  //driveTurnInPlace(currentHeading, PID_INPLACE_TURN_NORMAL, 20);
	  //driveHoldHeading(2500, -65, currentHeading, DRIVE_BACK_SONAR);

	  // Pick up last 3 stars
	  currentHeading += ROTATE_LEFT / 3;
	  driveTurnInPlace(currentHeading, PID_INPLACE_TURN_SMALL_NORMAL);
	  driveHoldHeading(100, 100, currentHeading, DRIVE_ENCODERS, ACCEL_FAST, 70);

	  // Don't do a turn here since hold heading will do a "smooth" turn automatically
	  currentHeading += ROTATE_RIGHT / 3;
	  driveHoldHeading(900, 100, currentHeading);
	  setClaw(1);
	  SetLiftHeight(LIFT_HIGH_HEIGHT);
	  driveHoldHeading(1000, 100, currentHeading, DRIVE_LINES);

	  currentHeading += ROTATE_RIGHT + ROTATE_RIGHT * 0.30;
	  driveTurnInPlace(currentHeading, PID_INPLACE_TURN_WITH_CUBE); // 3 stars = cube

	  // Score #5
    driveHoldHeading(550, 127, currentHeading, DRIVE_ENCODERS, ACCEL_FAST, 50, 4);
	  driveHoldHeading(550, 127, currentHeading, DRIVE_LINES, ACCEL_NONE, 127, 4);
	  setClaw(0);
	  drivePower(127);
	  wait1Msec(100);
	  drivePower(50);
	  wait1Msec(250);

	  // "Nudge" and get last star on fence
	  /*currentHeading += ROTATE_LEFT * 0.3 + ROTATE_LEFT * 0.30;
	  driveTurnInPlace(currentHeading);
	  driveHoldHeading(-300, -60, currentHeading);
	  currentHeading += ROTATE_RIGHT * 0.3;
	  driveTurnInPlace(currentHeading);
	  driveHoldHeading(600, 127, currentHeading, DRIVE_LINES);
	  drivePower(127);
	  wait1Msec(100);
	  drivePower(50);
	  wait1Msec(250);*/

	  currentHeading += ROTATE_LEFT * 0.30;

	  driveHoldHeading(-300, -100, currentHeading, DRIVE_ENCODERS, ACCEL_FAST, -70);
	  SetLiftHeight(LIFT_LOW_HEIGHT);
	  setClaw(1);
	  driveHoldHeading(6750, -110, currentHeading, DRIVE_BACK_SONAR, ACCEL_FAST, -100);

	  currentHeading += ROTATE_RIGHT;
	  //driveCorrectedSmoothTurn(currentHeading, -70, -80);
	  driveTurnInPlace(currentHeading);
	  driveHoldHeading(-300, -80, currentHeading, DRIVE_ENCODERS, ACCEL_FAST, -60);
	  driveHoldHeading(5500, -110, currentHeading, DRIVE_BACK_SONAR, ACCEL_FAST, -80);
	  driveHoldHeading(-200, -60, currentHeading, DRIVE_ENCODERS, ACCEL_SLOW, -80);
	  brake(-1);

	  currentHeading += ROTATE_RIGHT;
	  deployTimer = 250;
	  startTask(delayedDeploy);

	  driveTurnInPlace(currentHeading, PID_INPLACE_TURN_PUSHER_FALLING);
	  drivePower(0);
	  wait1Msec(400);

	  driveHoldHeading(-300, -127, currentHeading, DRIVE_RIGHT_LINES, ACCEL_FAST, -70);
	  drivePower(-127);
	  wait1Msec(500); // Push
	  driveHoldHeading(600, 70, currentHeading);

	  // Push #2
	  currentHeading += ROTATE_RIGHT;
	  driveTurnInPlace(currentHeading, PID_INPLACE_TURN_PUSHER);
	  driveHoldHeading(-650, -90, currentHeading);

	  currentHeading += ROTATE_LEFT;
	  driveTurnInPlace(currentHeading, PID_INPLACE_TURN_PUSHER);
	  driveHoldHeading(-200, -90, currentHeading);
	  SetLiftHeight(LIFT_LOW_HEIGHT);
	  driveHoldHeading(-500, -127, currentHeading, DRIVE_ENCODERS, ACCEL_FAST, -70, 4); // Push
	  drivePower(-127);
	  wait1Msec(250);

	  driveHoldHeading(100, 70, currentHeading);
	  SetLiftHeight(LIFT_SIDE_PUSH_HEIGHT);

	  driveHoldHeading(500, 70, currentHeading);

	  // Push #3
	  /*currentHeading += ROTATE_RIGHT;
	  driveTurnInPlace(currentHeading);
	  setPusher(0);

	  driveHoldHeading(-750, -90, currentHeading);

	  currentHeading += ROTATE_LEFT;
	  driveTurnInPlace(currentHeading, PID_INPLACE_TURN_WITH_CUBE);

	  setPusher(1);
	  drivePower(0);
	  wait1Msec(1000);
	  driveHoldHeading(-850, -90, currentHeading, DRIVE_ENCODERS, ACCEL_FAST, -70, 4); // Push
	  drivePower(-127);
	  wait1Msec(250);

	  SetLiftHeight(LIFT_SIDE_PUSH_HEIGHT);
	  driveHoldHeading(700, 70, currentHeading);
	  setPusher(0);
	  brake(1);*/

	  // Line up for Hanging bar
	  SetLiftHeight(LIFT_HIGH_HEIGHT);
	  currentHeading += ROTATE_RIGHT;
	  driveTurnInPlace(currentHeading);
	  setPusher(0);
	  driveHoldHeading(-500, -110, currentHeading, DRIVE_ENCODERS, ACCEL_FAST, -70 );
	  driveHoldHeading(2000, -55, currentHeading, DRIVE_BACK_SONAR);
    brake(-1);
	  currentHeading += ROTATE_RIGHT;
	  driveTurnInPlace(currentHeading);
	  driveHoldHeading(1400, -60, currentHeading, DRIVE_BACK_SONAR);
    brake(-1);
	  currentHeading += ROTATE_LEFT / 2;
	  driveOneWheel(currentHeading);
	  driveHoldHeading(-200, -55, currentHeading);
	  drivePower(-50);
	  wait1Msec(500);
	  drivePower(-20);
	  wait1Msec(250);
	  drivePower(0);
	  wait1Msec(250);

	  stopTask(liftHeight);
	  liftPower(-127);
	  wait1Msec(1500);
	  setHangingLock(1);
	  wait1Msec(1500);
	  //writeDebugStreamLine("Finished Hanging!");
	  liftPower(0);

	  //SetLiftHeight(LIFT_LOW_HEIGHT);*/
	  drivePower(0);
}

task autonomous()
{
	startTask(PixyPackets);
	float currentHeading = AutonCubeMid();
	toggleSonar(BACK_ON);
	currentHeading = PixyBackFromFence(-1, currentHeading);
	drivePower(0);
	PixyTurn();
	//PixyAutonNew();
	/*
	if(SensorValue(selector2) > 3000)
	{
  	PSC();
  }
  else
  {
  	AutonCubeMid();
  }
  */
}


#include "UserControl.c"
