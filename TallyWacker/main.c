#pragma config(UART_Usage, UART1, uartUserControl, baudRate38400, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartUserControl, baudRate38400, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorAnalog)
#pragma config(Sensor, in2,    rLine,          sensorAnalog)
#pragma config(Sensor, in3,    selector2,      sensorAnalog)
#pragma config(Sensor, in4,    pot,            sensorAnalog)
#pragma config(Sensor, in5,    lLine,          sensorLineFollower)
#pragma config(Sensor, in7,    selector1,      sensorNone)
#pragma config(Sensor, dgtl1,  liftLowerLimit, sensorDigitalIn)
#pragma config(Sensor, dgtl2,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  hangingLock,    sensorNone)
#pragma config(Sensor, dgtl7,  pusher,         sensorNone)
#pragma config(Sensor, dgtl8,  backSonar,      sensorSONAR_raw)
#pragma config(Sensor, dgtl12, intake,         sensorDigitalOut)
#pragma config(Sensor, I2C_1,  liftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           liftR1,        tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           driveL2,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           driveL1,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           driveL3,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           liftR2,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           liftL1,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           driveR3,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           liftL2,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           driveR1,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          driveR2,       tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "LCD_Vex_Competition_Includes.c"
#include "Robot.c"
#include "Auton.c"
#include "pixy.c"
#include "pixyAuto.c"

task gyroCalib()
{

}

void pre_auton()
{
  GyroInit(gyro);
  GyroCalibration();
  startTask(GyroTask);

  //writeDebugStreamLine("Gyro calib done");
	setClaw(0);
	setHangingLock(0);
	startTask(PixyPackets);
}

void clawFlip()
{
	SetLiftHeight(LIFT_LOW_HEIGHT);
  setClaw(1);
  wait1Msec(100);
  setClaw(0);
}

void AutonCubeFar()
{
  startTask(liftHeight);
  float currentHeading = 0;

  // Turn a little and pick up cube
  currentHeading += ROTATE_RIGHT * 0.15;
  clawFlip();
  driveHoldHeading(600, 100, currentHeading, DRIVE_ENCODERS);

  currentHeading += ROTATE_RIGHT * 0.35;

  setClaw(1);
  SetLiftHeight(LIFT_LITTLE_BIT_HEIGHT);
  driveTurnInPlace(currentHeading, PID_INPLACE_TURN_NORMAL, 20);
  driveHoldHeading(500, 100, currentHeading);
  currentHeading += ROTATE_LEFT;

  SetLiftHeight(LIFT_HIGH_HEIGHT);
  driveTurnInPlace(currentHeading);
  waitForLiftUp(LIFT_MID_CUBE_HEIGHT);

  // Score #1
  driveHoldHeading(200, 80, currentHeading);
  driveHoldHeading(550, 127, currentHeading, DRIVE_LINES, ACCEL_FAST, 80);
  setClaw(0);
  drivePower(127);
  wait1Msec(100);
  drivePower(50);
  wait1Msec(250);
	drivePower(0);


  drivePower(0);
}

float AutonCubeMid()
{
  startTask(liftHeight);
  float currentHeading = 0;

  // Turn a little and pick up cube
  currentHeading += ROTATE_RIGHT * 0.15;
  //clawFlip();
  driveHoldHeading(700, 100, currentHeading, DRIVE_ENCODERS);
  setClaw(1);
  SetLiftHeight(LIFT_MID_HEIGHT);

  // Turn towards fence
  currentHeading += ROTATE_LEFT / 2 + ROTATE_LEFT * 0.15;
  driveTurnInPlace(currentHeading);
  drivePower(0);
  waitForLiftUp(LIFT_LITTLE_BIT_HEIGHT);

  // Score #1
  driveHoldHeading(100, 80, currentHeading);
  driveHoldHeading(700, 127, currentHeading, DRIVE_LINES, ACCEL_FAST, 80);
  setClaw(0);
  drivePower(127);
  wait1Msec(100);
  drivePower(50);
  wait1Msec(250);
	drivePower(0);

	currentHeading += ROTATE_RIGHT * (1.0/1.7);
	driveHoldHeading(-300, -65, currentHeading);
	SetLiftHeight(LIFT_LOW_HEIGHT);
	driveHoldHeading(-1000, -100, currentHeading, DRIVE_ENCODERS, ACCEL_FAST, -60);

	currentHeading += ROTATE_RIGHT * (0.8/1.7);
	driveTurnInPlace(currentHeading);
  driveHoldHeading(2000, 110, currentHeading, DRIVE_ENCODERS, ACCEL_FAST, 60);
  setClaw(1);
  drivePower(0);
  wait1Msec(300);
  driveHoldHeading(-50, -100, currentHeading);
  SetLiftHeight(LIFT_HIGH_HEIGHT);
  waitForLiftUp(LIFT_LITTLE_BIT_HEIGHT);

  currentHeading += ROTATE_LEFT + ROTATE_LEFT * (0.1/1.7);
  driveTurnInPlace(currentHeading);

  driveHoldHeading(400, 80, currentHeading);
  driveHoldHeading(550, 127, currentHeading, DRIVE_LINES, ACCEL_FAST, 80);
  setClaw(0);
  drivePower(127);
  wait1Msec(100);
  drivePower(50);
  wait1Msec(250);
	drivePower(0);

	return currentHeading;
}

task autonomous()
{
	autoQuit = 0;
	AutonCubeMid();
	/*float currentHeading;
	if(SensorValue(selector2) > 3000)
	{
  	PSC();
  }
  else
  {
  	currentHeading = AutonCubeMid();
  	PixyAuton(currentHeading);
  }*/
}

#include "UserControl.c"
