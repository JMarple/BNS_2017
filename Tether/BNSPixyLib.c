//#pragma config(UART_Usage, UART1, uartUserControl, baudRate38400, IOPins, None, None)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

typedef struct
{
	int sig;
	int x;
	int y;
	int width;
	int height;
} PixyBlock;

PixyBlock pixyBlocks[10];
int pixyBlockNum;
bool pixyBlockHasUpdated;

char getNextChar()
{
	while (1)
	{
		short c = getChar(UART1);

		if (c != -1)
			return (char)c;
	}
}

int getNextInt()
{
	char n1 = getNextChar();
	char n2 = getNextChar();
	return n1 | (n2 << 8);
}

task pixyUpdate()
{
	int skip = false;
	int count = 0;
	int zeroCount = 0;
	while (1)
	{
		pixyBlockNum = count;
		pixyBlockHasUpdated = true;
		count = 0;
		char c = 0xFF;

		while(skip == false)
		{
			if (c == 0) zeroCount++;

			if (zeroCount > 10)
			{
				zeroCount = 0;
				pixyBlockNum = 0;
				pixyBlockHasUpdated = true;
			}
			// Look for 0xAA55 tag
			c = getNextChar();
			if (c != 0x55) continue;

			c = getNextChar();
			if (c != 0xaa) continue;

			c = getNextChar();
			if (c != 0x55) continue;

			c = getNextChar();
			if (c != 0xaa) continue;

			break;
		}

		skip = false;

		while(1)
		{
			// We don't care about checksum for now
			char cs1 = getNextChar();
			char cs2 = getNextChar();

			if (cs1 == 85 && cs2 == 170)
			{
				skip = true;
				break;
			}

			// Data
			int sig = getNextInt();
		  int x = getNextInt();
		  int y = getNextInt();
		  int width = getNextInt();
		  int height = getNextInt();

		  if (count >= 10) break;

		  pixyBlocks[count].sig = sig;
		  pixyBlocks[count].x = x;
		  pixyBlocks[count].y = y;
		  pixyBlocks[count].width = width;
		  pixyBlocks[count].height = height;

		  count++;

		  int c1 = getNextChar();
		  int c2 = getNextChar();
		  if (c1 != 0x55 || c2 != 0xAA) break;
		}
  }
}
